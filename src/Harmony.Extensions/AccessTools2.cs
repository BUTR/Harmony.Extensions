// <auto-generated>
//   This code file has automatically been added by the "Harmony.Extensions" NuGet package (https://www.nuget.org/packages/Harmony.Extensions).
//   Please see https://github.com/BUTR/Harmony.Extensions for more information.
//
//   IMPORTANT:
//   DO NOT DELETE THIS FILE if you are using a "packages.config" file to manage your NuGet references.
//   Consider migrating to PackageReferences instead:
//   https://docs.microsoft.com/en-us/nuget/consume-packages/migrate-packages-config-to-package-reference
//   Migrating brings the following benefits:
//   * The "Harmony.Extensions" folder and the "AccessTools2.cs" file don't appear in your project.
//   * The added file is immutable and can therefore not be modified by coincidence.
//   * Updating/Uninstalling the package will work flawlessly.
// </auto-generated>

#region License
// MIT License
//
// Copyright (c) Bannerlord's Unofficial Tools & Resources
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
#endregion

using System.Diagnostics;

#if !HARMONYEXTENSIONS_DISABLE
#nullable enable
#pragma warning disable

namespace HarmonyLib.BUTR.Extensions
{
    using global::HarmonyLib;

    using global::System.Diagnostics.CodeAnalysis;
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Linq;
    using global::System.Linq.Expressions;
    using global::System.Reflection;

    using static global::HarmonyLib.AccessTools;

    /// <summary>An extension of Harmony's helper class for reflection related functions</summary>
    internal static partial class AccessTools2
    {
        /// <summary>Enumerates all assemblies in the current app domain, excluding visual studio assemblies</summary>
        /// <returns>An enumeration of <see cref="Assembly"/></returns>
        public static IEnumerable<Assembly> AllAssemblies() => 
            AppDomain.CurrentDomain.GetAssemblies().Where(a => a.FullName.StartsWith("Microsoft.VisualStudio") is false);

        /// <summary>Enumerates all successfully loaded types in the current app domain, excluding visual studio assemblies</summary>
        /// <returns>An enumeration of all <see cref="Type"/> in all assemblies, excluding visual studio assemblies</returns>
        public static IEnumerable<Type> AllTypes() => AllAssemblies().SelectMany(a => GetTypesFromAssembly(a));

        /// <summary>Gets a type by name. Prefers a full name with namespace but falls back to the first type matching the name otherwise</summary>
        /// <param name="name">The name</param>
        /// <returns>A type or null if not found</returns>
        ///
        public static Type TypeByName(string name)
        {
            var type = Type.GetType(name, false);
            if (type is null)
                type = AllTypes().FirstOrDefault(t => t.FullName == name);
            if (type is null)
                type = AllTypes().FirstOrDefault(t => t.Name == name);
            if (type is null)
                Trace.TraceError($"AccessTools2.TypeByName: Could not find type named {name}");
            return type;
        }

        /// <summary>Applies a function going up the type hierarchy and stops at the first non-<c>null</c> result</summary>
        /// <typeparam name="T">Result type of func()</typeparam>
        /// <param name="type">The class/type to start with</param>
        /// <param name="func">The evaluation function returning T</param>
        /// <returns>The first non-<c>null</c> result, or <c>null</c> if no match</returns>
        /// <remarks>
        /// The type hierarchy of a class or value type (including struct) does NOT include implemented interfaces,
        /// and the type hierarchy of an interface is only itself (regardless of whether that interface implements other interfaces).
        /// The top-most type in the type hierarchy of all non-interface types (including value types) is <see cref="object"/>.
        /// </remarks>
        ///
        public static T FindIncludingBaseTypes<T>(Type type, Func<Type, T> func) where T : class
        {
            while (true)
            {
                var result = func(type);
                if (result is object) return result;
                type = type.BaseType;
                if (type is null) return null;
            }
        }

        private static FieldInfo? GetInstanceField(Type type, string fieldName)
        {
            var fieldInfo = Field(type, fieldName);
            if (fieldInfo is null)
                return null;
            if (fieldInfo.IsStatic)
            {
                return null;
                Trace.TraceError("AccessTools2.GetInstanceField: Field must not be static");
            }
            return fieldInfo;
        }

        private static bool ValidateFieldType<F>(FieldInfo? fieldInfo)
        {
            if (fieldInfo is null)
                return false;

            var returnType = typeof(F);
            var fieldType = fieldInfo.FieldType;
            if (returnType == fieldType)
                return false;

            if (fieldType.IsEnum)
            {
                var underlyingType = Enum.GetUnderlyingType(fieldType);
                if (returnType != underlyingType)
                {
                    Trace.TraceError($"FieldRefAccess return type must be the same as FieldType or FieldType's underlying integral type ({underlyingType}) for enum types");
                    return false;
                }
            }
            else if (fieldType.IsValueType)
            {
                // Boxing/unboxing is not allowed for ref values of value types.
                Trace.TraceError("FieldRefAccess return type must be the same as FieldType for value types");
                return false;
            }
            else
            {
                if (returnType.IsAssignableFrom(fieldType) is false)
                {
                    Trace.TraceError("FieldRefAccess return type must be assignable from FieldType for reference types");
                    return false;
                }
            }

            return true;
        }

        private static bool TryGetComponents(string typeColonName, out Type? type, out string? name)
        {
            if (string.IsNullOrWhiteSpace(typeColonName))
            {
                if (Harmony.DEBUG)
                    FileLog.Log("AccessTools2.GetComponents: typeColonName is null or whitespace/empty");

                type = null;
                name = null;
                return false;
            }

            var parts = typeColonName.Split(':');
            if (parts.Length != 2)
            {
                if (Harmony.DEBUG)
                    FileLog.Log("AccessTools2.GetComponents: Name must be specified as 'Namespace.Type1.Type2:Name");

                type = null;
                name = null;
                return false;
            }

            type = TypeByName(parts[0]);
            name = parts[1];
            return type is not null;
        }
    }
}

#pragma warning restore
#nullable restore
#endif // HARMONYEXTENSIONS_DISABLE